# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BHCgeo_QGIS
                                 A QGIS plugin
 Calculates the Climatic Water Balance in each pixel
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-06-22
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Carvalho Neto, R.M./UFSM; Cruz, J.C./UFSM; Cruz, R.C./UNIPAMPA
        email                : romariocarvalho@hotmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QFileDialog

from qgis.core import Qgis
import gdal, osr, io
import numpy as np 
from math import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .BHCgeoQGIS_dialog import BHCgeo_QGISDialog
import os.path


class BHCgeo_QGIS:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'BHCgeo_QGIS_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&BHCgeo')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('BHCgeo_QGIS', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToRasterMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/BHCgeoQGIS/figBHC.png'
        self.add_action(
            icon_path,
            text=self.tr(u'BHCgeo'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginRasterMenu(
                self.tr(u'&BHCgeo'),
                action)
            self.iface.removeToolBarIcon(action)

    def select_output_file(self):      
        filename = QFileDialog.getExistingDirectory(self.dlg, ("Choose the output folder"))
        self.dlg.lineEdit.setText(filename)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = BHCgeo_QGISDialog()
            self.dlg.pushButton.clicked.connect(self.select_output_file)
        
        self.dlg.comboBox.clear()                          
        
        # meses_list = ["January","February","March","April",
                        # "May","June","July","August","September",
                        # "October","November","December"] 
        meses_list = [QCoreApplication.translate('self.dlg.comboBox', "January"),
                        QCoreApplication.translate('self.dlg.comboBox', "February"),
                        QCoreApplication.translate('self.dlg.comboBox', "March"),
                        QCoreApplication.translate('self.dlg.comboBox', "April"),
                        QCoreApplication.translate('self.dlg.comboBox', "May"),
                        QCoreApplication.translate('self.dlg.comboBox', "June"),
                        QCoreApplication.translate('self.dlg.comboBox', "July"),
                        QCoreApplication.translate('self.dlg.comboBox', "August"),
                        QCoreApplication.translate('self.dlg.comboBox', "September"),
                        QCoreApplication.translate('self.dlg.comboBox', "October"),
                        QCoreApplication.translate('self.dlg.comboBox', "November"),
                        QCoreApplication.translate('self.dlg.comboBox', "December")] 

        self.dlg.comboBox.addItems(meses_list)
        
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:

            pastaSelecionada = self.dlg.lineEdit.text()  
            diretorio = pastaSelecionada+"\\"
             
            listaMesDesordenada = ['Jan','Fev','Mar','Abr','Mai','Jun','Jul','Ago','Set','Out','Nov','Dez'] 
            nomeMes = []
            mesEscolhidoIndex = self.dlg.comboBox.currentIndex()

            cont = mesEscolhidoIndex
            for mes in range(len(listaMesDesordenada) - mesEscolhidoIndex):
                nomeMes.append(listaMesDesordenada[cont])
                cont += 1
            cont = 0
            for mes in range(mesEscolhidoIndex):
                nomeMes.append(listaMesDesordenada[cont]) 
                cont += 1
            #-----------------------------------------------------------

            NoData = -9999
            CAD_raster = gdal.Open(diretorio+"cad.tif")   
            bandaUnicaCAD = CAD_raster.GetRasterBand(1)
            bandaUnicaCAD.SetNoDataValue(NoData)
            CAD_array = np.array(bandaUnicaCAD.ReadAsArray())
            CAD_list = []
            CAD_list.append(CAD_array.tolist())
            ETP_list = [[] for mes in nomeMes]
            P_list = [[] for mes in nomeMes]

            contMes = 0
            for mes in nomeMes:
                ETP_raster = gdal.Open(diretorio+"etp"+mes+".tif")   
                bandaUnicaETP = ETP_raster.GetRasterBand(1)
                bandaUnicaETP.SetNoDataValue(NoData)
                ETP_array = np.array(bandaUnicaETP.ReadAsArray()) 
                ETP_listMes = ETP_array.tolist()
                ETP_list[contMes].append(ETP_listMes)
                P_raster = gdal.Open(diretorio+"p"+mes+".tif")   
                bandaUnicaP = P_raster.GetRasterBand(1)
                bandaUnicaP.SetNoDataValue(NoData)
                P_array = np.array(bandaUnicaP.ReadAsArray()) 
                P_listMes = P_array.tolist()
                P_list[contMes].append(P_listMes)
                contMes += 1

            # ---------------- Verificando as condicoes para fazer os calculos ---------------------------

            for mes in nomeMes:
                CAD_raster = gdal.Open(diretorio+"cad.tif")
                ETP_raster = gdal.Open(diretorio+"etp"+mes+".tif") 
                P_raster = gdal.Open(diretorio+"p"+mes+".tif")
                assert CAD_raster.RasterXSize == ETP_raster.RasterXSize == P_raster.RasterXSize 
                assert CAD_raster.RasterYSize == ETP_raster.RasterYSize == P_raster.RasterYSize 

            #-------------------- Substituindo valores de CAD = 0 por NoData ------------------------------

            for matriz in range(len(CAD_list)):
                for row in range(len(CAD_list[matriz])):
                    for i in range(len(CAD_list[matriz][row])):
                        if CAD_list[matriz][row][i] == 0:
                            CAD_list[matriz][row].pop(i)    # retira o cad 0 e substitui por NODATA
                            CAD_list[matriz][row].insert(i,NoData)            

            #-------------------- Retirando as linhas que vem do formato array ------------------------------

            CADFloatAll = []
            ETPFloatAll = [[] for mes in nomeMes]
            PFloatAll = [[] for mes in nomeMes]

            for matriz in range(len(CAD_list)):
                for row_cont in range(len(CAD_list[matriz])):
                    for item in range(len(CAD_list[matriz][row_cont])):
                        CADFloatAll.append(CAD_list[matriz][row_cont][item])

            for mes in range(len(nomeMes)):
                for matriz in range(len(ETP_list[mes])):     
                    for row_cont in range(len(ETP_list[mes][matriz])):
                        for item in range(len(ETP_list[mes][matriz][row_cont])):
                            ETPFloatAll[mes].append(ETP_list[mes][matriz][row_cont][item])
                            PFloatAll[mes].append(P_list[mes][matriz][row_cont][item])

            #--------------------------- Fazendo o calculo ---------------------------------------------

            ARM = [[] for i in range(len(nomeMes))]
            ETR = [[] for i in range(len(nomeMes))]
            B = [[] for i in range(len(nomeMes))]

            for mes in range(len(nomeMes)):
                if mes == 0:  # primeiro mes
                    for cell in range(len(CADFloatAll)):
                        if PFloatAll[mes][cell] == NoData or ETPFloatAll[mes][cell] == NoData:
                            ARM[mes].append(NoData) #nao faz o calculo para NoData
                        else:
                            ARM[mes].append(CADFloatAll[cell])

                    cont_i = 0
                    for i in PFloatAll[mes]:
                        if CADFloatAll[cont_i] == NoData or PFloatAll[mes][cont_i] == NoData or ETPFloatAll[mes][cont_i] == NoData:
                            B[mes].append(NoData)     #nao faz o calculo para NoData
                            ETR[mes].append(NoData)
                            cont_i += 1
                            
                        elif PFloatAll[mes][cont_i] - ETPFloatAll[mes][cont_i] > 0: #excesso
                            if ARM[mes][cont_i] + (PFloatAll[mes][cont_i] - ETPFloatAll[mes][cont_i]) >= CADFloatAll[cont_i]:
                                B[mes].append(PFloatAll[mes][cont_i] - ETPFloatAll[mes][cont_i]) #sempre para o mes zero B = Pi-ETPi
                                ETR[mes].append(ETPFloatAll[mes][cont_i])
                                cont_i += 1
                            else:
                                assert ARM[mes][cont_i] + (PFloatAll[mes][cont_i] - ETPFloatAll[mes][cont_i]) >= CADFloatAll[cont_i]#, print("\n"+
                                    #"  ---> COMECOU COM MES ERRADO! O arm anterior deve ser igual a CAD quando roda o modelo a primeira vez! <---  ")
                                break
                                
                        else: # defict   ---> teoricamente nao deveria ter essa possibilidade no primeiro mes,pois deve ser escolhido um mes com P>ETP para iniciar
                            form = ARM[mes][cont_i] * exp((PFloatAll[mes][cont_i] - ETPFloatAll[mes][cont_i]) / CADFloatAll[cont_i])
                            if form > 0: 
                                # Neste primeiro mes, form = ARM do mes em questao (mes zero) e ARM[mes] == ARM do mes anterior
                                B[mes].append((PFloatAll[mes][cont_i] + (ARM[mes][cont_i] - form)) - ETPFloatAll[mes][cont_i]) 
                                ARM_mes_anterior = ARM[mes][cont_i] #guarda o valor de arm que vai ser atualizado
                                ARM[mes].pop(cont_i)
                                ARM[mes].insert(cont_i,form)
                                ETR[mes].append(PFloatAll[mes][cont_i] + (ARM_mes_anterior - form)) #teoricamente nao deveria ter ETR no primeiro mes
                                cont_i += 1                                                         #pois deve ser escolhido um mes com P>ETP para iniciar
                            else:
                                assert form > 0#, print("  ---> ERRO MATEMATICO! Nao pode acontecer tal resultado. <---  ")
                                break
                                
                else:  # outros meses
                    cont_i = 0
                    for i in PFloatAll[mes]:
                        if CADFloatAll[cont_i] == NoData or PFloatAll[mes][cont_i] == NoData or ETPFloatAll[mes][cont_i] == NoData:
                            B[mes].append(NoData)     #nao faz o calculo para NoData
                            ARM[mes].append(NoData)     #nao faz o calculo para NoData
                            ETR[mes].append(NoData)
                            cont_i += 1
                            
                        elif PFloatAll[mes][cont_i] - ETPFloatAll[mes][cont_i] > 0: #excesso
                            if ARM[mes-1][cont_i] + (PFloatAll[mes][cont_i] - ETPFloatAll[mes][cont_i]) >= CADFloatAll[cont_i]:
                                ARM[mes].append(CADFloatAll[cont_i])
                                ETR[mes].append(ETPFloatAll[mes][cont_i])
                                B[mes].append(ARM[mes-1][cont_i] + (PFloatAll[mes][cont_i] - ETPFloatAll[mes][cont_i]) - CADFloatAll[cont_i])
                                cont_i += 1
                            else:
                                ARM[mes].append(ARM[mes-1][cont_i] + (PFloatAll[mes][cont_i] - ETPFloatAll[mes][cont_i]))
                                ETR[mes].append(ETPFloatAll[mes][cont_i])
                                B[mes].append(0)
                                cont_i += 1
                                
                        else: # defict
                            form = ARM[mes-1][cont_i] * exp((PFloatAll[mes][cont_i] - ETPFloatAll[mes][cont_i]) / CADFloatAll[cont_i])
                            if form > 0:
                                ARM[mes].append(form)
                                ETR[mes].append(PFloatAll[mes][cont_i] + (ARM[mes-1][cont_i]-ARM[mes][cont_i]))
                                B[mes].append((PFloatAll[mes][cont_i] + (ARM[mes-1][cont_i]-ARM[mes][cont_i])) - ETPFloatAll[mes][cont_i])
                                cont_i += 1
                            else:
                                assert form > 0#, print("  ---> ERRO MATEMATICO! Nao pode acontecer tal resultado. <---  ")
                                break

            if self.dlg.checkBox_PR.isChecked():

                # ---------------------------- PROVA REAL -------------------------------------

                listaRelatorio = []                
                texto = QCoreApplication.translate('report', '''The Verification Proof checks if the following conditions were respected, in each pixel:
                
    Sum(ETP) = Sum(ETR)+Sum(DEF)
    Sum(P) = Sum(ETR)+Sum(EXC)
    Sum(Alt) = 0

    Where DEF(Water Deficit) = B negative, EXC(Water Excess) = B positive and Alt
is the alteration sufered by ARM, from one month to the next.

    If these conditions are not met, the report will point out the first pixel
where the error occurred, with a tolerance of 0.9 mm. Therefore, it is very likely
that there are other pixels with the same error. This means that another month 
should be chosen to be the first in the Climatic Water Balance (BHC) calculations.

    The month prior to the one chosen to start the BHC should have its ground water 
storage totally filled, this means that in the previous month, ARM must be equal to 
CAD, that is, the month prior to the first (and preferably the first month as well)
should not be a month of water deficit.

    If you do not have an idea when to start the BHC, you should run several tests 
(Verification Proof) to identify when to start and thus produce the most reliable 
outputs.

    If it is a very large and/or very heterogeneous area, climatologically, and all
Verification Proofs found out errors, the inputs are suggested to be fragmented in 
smaller areas to better represent their climatological characteristics.


    ******************************* REPORT ******************************
            ''')

                listaRelatorio.append(texto)

                somatorioP = [ [] for cell in CADFloatAll ]  #somatorio por pixel
                somatorioETP = [ [] for cell in CADFloatAll ]
                somatorioETR = [ [] for cell in CADFloatAll ]
                somatorioDEF = [ [] for cell in CADFloatAll ]
                somatorioEXC = [ [] for cell in CADFloatAll ]
                somatorioAlt = [ [] for cell in CADFloatAll ]

                for cell in range(len(CADFloatAll)):
                    for mes in range(len(nomeMes)):
                        if ETR[mes][cell] == NoData:  # B[mes][cell] == NoData or PFloatAll[mes][cell] == NoData or ETPFloatAll[mes][cell] == NoData:
                            somatorioP[cell].append(NoData)
                            somatorioETP[cell].append(NoData)
                            somatorioETR[cell].append(NoData)
                            somatorioEXC[cell].append(NoData)
                            somatorioDEF[cell].append(NoData)
                            somatorioAlt[cell].append(NoData)
                        else:
                            somatorioP[cell].append(PFloatAll[mes][cell])
                            somatorioETP[cell].append(ETPFloatAll[mes][cell])
                            somatorioETR[cell].append(ETR[mes][cell])
                            somatorioAlt[cell].append(ARM[mes][cell]-ARM[mes-1][cell])

                            if B[mes][cell] > 0:
                                somatorioEXC[cell].append(B[mes][cell])
                            else:
                                somatorioDEF[cell].append(B[mes][cell]) 

                for cell in range(len(CADFloatAll)):
                    if NoData in somatorioETR[cell]: # pois ETR eh saida com NoData nos lugares certos
                        pass
                    else:
                        arredondandoSomETP = sum(somatorioETP[cell])
                        arredondandoSomP = sum(somatorioP[cell])
                        arredondandoSomETR = sum(somatorioETR[cell])
                        arredondandoSomDEF = abs(sum(somatorioDEF[cell]))
                        arredondandoSomEXC = sum(somatorioEXC[cell])
                        arredondandoSomAlt = sum(somatorioAlt[cell])

                        if arredondandoSomETP == arredondandoSomETR + arredondandoSomDEF:
                            erro = "SEM ERRO"
                        elif abs(arredondandoSomETP - (arredondandoSomETR + arredondandoSomDEF)) < 1: #limite aceitavel, em mm, para fins de arredondamento
                            erro = "SEM ERRO"
                        else: 
                            mensagemRelatorio = ("\nPixel: "+str(cell)+"\n"+
                                QCoreApplication.translate("mensagemRelatorio","Sum(ETP): ")+
                                str(arredondandoSomETP)+"\n"+
                                QCoreApplication.translate("mensagemRelatorio","Sum(ETR)+Sum(DEF): ")+
                                str(arredondandoSomETR+arredondandoSomDEF)+"\n\n"+
                                QCoreApplication.translate("mensagemRelatorio", 
                                "In this pixel, the Verification Proof found a possible error. Choose another month to start with."))
                            listaRelatorio.append(mensagemRelatorio+"\n")
                            erro = "ERRO"
                            break
                        if arredondandoSomP == arredondandoSomETR + arredondandoSomEXC:
                            erro = "SEM ERRO"
                        elif abs(arredondandoSomP - (arredondandoSomETR + arredondandoSomEXC)) < 1: #limite aceitavel, em mm, para fins de arredondamento
                            erro = "SEM ERRO"
                        else: 
                            mensagemRelatorio = ("\nPixel: "+str(cell)+"\n"+
                                QCoreApplication.translate("mensagemRelatorio","Sum(P): ")+
                                str(arredondandoSomP)+"\n"+
                                QCoreApplication.translate("mensagemRelatorio","Sum(ETR)+Sum(EXC): ")+
                                str(arredondandoSomETR+arredondandoSomEXC)+"\n\n"+
                                QCoreApplication.translate("mensagemRelatorio", 
                                "In this pixel, the Verification Proof found a possible error. Choose another month to start with."))
                            listaRelatorio.append(mensagemRelatorio+"\n")
                            erro = "ERRO"
                            break
                        if arredondandoSomAlt == 0:
                            erro = "SEM ERRO"
                        elif arredondandoSomAlt < 1:
                            erro = "SEM ERRO"
                        else:
                            mensagemRelatorio = ("\nPixel: "+str(cell)+"\n"+
                                QCoreApplication.translate("mensagemRelatorio","Sum(Alt): ")+
                                str(arredondandoSomAlt)+"\n\n"+
                                QCoreApplication.translate("mensagemRelatorio",
                                "In this pixel, the Verification Proof found a possible error. Choose another month to start with"))
                            listaRelatorio.append(mensagemRelatorio+"\n")
                            erro = "ERRO"
                            break                            
                        
                if erro == "ERRO":
                    mensagemRelatorio = QCoreApplication.translate("mensagemRelatorio",
'''\n--> The Verification Proof found out, in at least one pixel, the existence of a possible error.

            ***** CONSIDER GETTING STARTED WITH ANOTHER MONTH *****''')
                    listaRelatorio.append(mensagemRelatorio+"\n")
                elif erro == "SEM ERRO":
                    mensagemRelatorio = QCoreApplication.translate("mensagemRelatorio",
'''\n--> The Verification Proof found out that the conditions of equality, according to the formulas,
were maintained in all pixels.''')
                    listaRelatorio.append(mensagemRelatorio+"\n")
                else:
                    mensagemRelatorio = str(erro) # nunca deve acontecer
                    listaRelatorio.append(mensagemRelatorio+"\n")
                    
                abrirRelatorio = io.open(diretorio+QCoreApplication.translate("mensagemRelatorio",
                    "Report.txt"), mode="w", encoding="utf-8")
                for i in listaRelatorio:
                    abrirRelatorio.write(unicode(i))
                abrirRelatorio.close()
                
            # -------------------- Criando os Rasters Finais -------------------------------

            B_array = [[[] for rows in CAD_array] for mes in nomeMes]  # cria os espacos para os rows que tem nos arquivos de entrada, para virar array
            ARM_array = [[[] for rows in CAD_array] for mes in nomeMes]
            ETR_array = [[[] for rows in CAD_array] for mes in nomeMes]

            for mes in range(len(nomeMes)):
                item_cont = 0
                for row in range(len(CAD_array)):
                    for item in range(len(CAD_array[row])):
                        B_array[mes][row].append(B[mes][item_cont])
                        ARM_array[mes][row].append(ARM[mes][item_cont])
                        ETR_array[mes][row].append(ETR[mes][item_cont])
                        item_cont += 1 

            dataset = gdal.Open(diretorio+'cad.tif') #raster modelo de tamanho pixel
            geotransform = dataset.GetGeoTransform()
            if geotransform:
                instantiatePixelWidth = geotransform[1]
                instantiatePixelHeight = geotransform[5]
                
            def array2raster(rasterfn,newRasterfn,array):
                raster = gdal.Open(rasterfn) #raster modelo
                geotransform = raster.GetGeoTransform()
                originX = geotransform[0] 
                originY = geotransform[3]
                pixelWidth = instantiatePixelWidth
                pixelHeight = instantiatePixelHeight
                cols = raster.RasterXSize
                rows = raster.RasterYSize

                driver = gdal.GetDriverByName('GTiff')
                outRaster = driver.Create(newRasterfn, cols, rows, 1, gdal.GDT_Float32)
                outRaster.SetGeoTransform((originX, pixelWidth, 0, originY, 0, pixelHeight))
                outband = outRaster.GetRasterBand(1)
                outband.WriteArray(array)
                outband.SetNoDataValue(NoData) #nao insere valor de NoData, mas sim, escolhe um valor dentre os existentes
                outRasterSRS = osr.SpatialReference()
                outRasterSRS.ImportFromWkt(raster.GetProjectionRef())
                outRaster.SetProjection(outRasterSRS.ExportToWkt())
                outband.FlushCache()

            rasterModelo = diretorio+'cad.tif'  # usa os parametros do raster modelo

            if self.dlg.checkBox_B.isChecked():
                contMes = 0
                for mes in nomeMes:
                    rasterSaidaB = diretorio+'b'+mes+'.tif'
                    my_array_B = np.array(B_array[contMes])
                    array2raster(rasterModelo, rasterSaidaB, my_array_B)
                    self.iface.addRasterLayer(rasterSaidaB, 'b'+mes)  #tem que adicionar .self para que funcione, pois iface foi referenciado la em cima
                    contMes += 1

            if self.dlg.checkBox_ETR.isChecked():
                contMes = 0
                for mes in nomeMes:
                    rasterSaidaETR = diretorio+'etr'+mes+'.tif'
                    my_array_ETR = np.array(ETR_array[contMes])
                    array2raster(rasterModelo, rasterSaidaETR, my_array_ETR)
                    self.iface.addRasterLayer(rasterSaidaETR, 'etr'+mes)     #tem que adicionar .self para que funcione, pois iface foi referenciado la em cima
                    contMes += 1

            if self.dlg.checkBox_ARM.isChecked():
                contMes = 0
                for mes in nomeMes:
                    rasterSaidaARM = diretorio+'arm'+mes+'.tif'
                    my_array_ARM = np.array(ARM_array[contMes])
                    array2raster(rasterModelo, rasterSaidaARM, my_array_ARM)
                    self.iface.addRasterLayer(rasterSaidaARM, 'arm'+mes)     #tem que adicionar .self para que funcione, pois iface foi referenciado la em cima
                    contMes += 1

            self.iface.messageBar().pushMessage("BHCgeo",
                QCoreApplication.translate("mensagemRelatorio","END of the BHCgeo"),
                level=Qgis.Success, duration=4)